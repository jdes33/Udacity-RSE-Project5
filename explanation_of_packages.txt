Below is a brief explanation of each of the relevant packages I used for the Home Service Robot project.


_____gmapping_____: 
This package performs SLAM to build a map of the environment. However I did not use it in my scripts excplicitly as the amcl_demo.launch file was in the turtlebot_gazebo package (see below) though I kept it in my project as it was in the project instructions to use it. 


_____turtlebot_telop_____: 
The turtlebot telop package is used for controlling the robot manually (via the keyboard).
I used this for testing SLAM (to build a map of the environment). I utilised the turtlebot_teleop node via the keyboard_teleop launch file. This node (contained in the turtlebot_teleop_key.py file) publishes Twist messages to the cmd_vel topic based on user input in order to control the robot.


_____turtlebot_gazebo_____:
I ran the turtlebot_world launch file to spawn the turtlebot in a world in gazebo simulator. This file sets many arguments such as the base, 3d_sensor, world_file etc. The file also runs nodes responsible for publishing the state of the robot and setting up the laser. When running the launch file I provided a value/path for world_file as I wanted to use my own world file instead of the default.

The package also contains the amcl_demo.launch file and the gmapping_demo.launch file that I used in my scripts. Both of these files depend on the turtlebot_navigation package. 


_____turtlebot_navigation_____:
This package was installed with ROS so I didn't need to reinstall it. This package utilises the move_base, amcl and gmapping packages (which are obviously also installed with ros). TurtleBot navigation motion is generated by the move_base package, which maintains a local and global costmap so it can create global and local plans. It uses Djikstra's algorithm to create the plans that I used were used to guide the robot to the pickup and dropoff locations. The TurtleBot localization is provided by the amcl (adaptive monte carlo localisation) package. TurtleBot maps are built with the gmapping package (a wrapper for OpenSlam's Gmapping), which takes in LaserScan messages to build an occupancy grid map.



_____turtlebot_rviz_launchers_____:
This package containes launch files for a few configurations of rviz. The one I used was the view_navigation.launch file. This launches the navigation.rviz file from the package which is preconfigured to show the necessary elements one would need to see when using the ros navigation stack with the turtlebot (amcl particle swarm, planner, costmap, map, lasercan, robotModel, grid...). This means I didn't have to set this up myself. However, I needed to add a marker to this rviz configuration (to show the object). I did this by launching this configuration, adding a marker and then saving it as a new configuration.



______pick_objects_____: 
This is a package I created (with a node called pick_objects) to instruct the robot to move the pickup and dropoff locations. It does this by sending a goal (using an action client) to the navigation stack each time it wants to move to a location. Once the goal is sent it waits till the action is done processing the goal and then checks if it was successful. I used a parameter in this node, which I called object_location, to keep track of where the object is. This parameter holds a string value which would either be "pickup_zone", "robot" or "dropoff zone" depending on where the object is. I updated the values of this parameter within this node (no other node sets the value of this parameter).


______add_markers_____: 
This is a package I created with two nodes. The first node, add_markers, is used to display a marker (a blue cylinder). The user must manually add a marker to rviz, then the marker will be displayed at the pickup zone for 5 seconds, be hidden for 5 seconds and then be shown at the dropoff location indefinitely. The second node, add_markers_goal_based, is used to display the marker based on the robot position. Initially the marker will be at the pickup location then, when the robot reaches it it will be hidden (to depict it being on the robot) until it the robot returns to the dropoff location where the marker will appear and remain indefinitely. In order to update the marker I needed to know where the robot was. I did this by requesting the object_location parameter from the parameter server (which I set in the pick_object node of the pick_objects package). Once I knew where the robot was I could easily set adjust the marker using conditional statements.

